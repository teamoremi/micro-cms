# Backend Integration & Usage Patterns

Micro-CMS is a decoupled runtime. The Admin UI is a consumer of capabilities, not a part of a monolithic core. This provides two primary integration patterns.

---

## Scenario 1: You Have an Existing REST API

If you already have a backend with CRUD endpoints, you can use Micro-CMS to instantly generate a full-featured admin panel for it.

### Module to Use: `@micro-cms/node-adapter`

This module is a "translator." It doesn't have any backend logic itself; it simply connects to your existing API and tells the Micro-CMS UI how to communicate with it.

### Backend API Contract

For the `@micro-cms/node-adapter` to work, your existing API **must** expose the following endpoints and data structures.

#### 1. The Schema Endpoint
The adapter will make a `GET` request to this endpoint to understand your data models.

- **Endpoint:** `GET /admin/schema`
- **Response Body:** A JSON object where keys are resource names and values are their definitions.

```json
{
  "resources": {
    "posts": {
      "label": "Blog Posts",
      "primaryKey": "id",
      "displayField": "title",
      "fields": [
        { "name": "id", "type": "number", "readOnly": true },
        { "name": "title", "type": "text", "required": true },
        { "name": "content", "type": "text" },
        { "name": "is_published", "type": "boolean" },
        { "name": "author_id", "type": "relation", "relation": { "targetEntity": "users", "displayField": "name" } }
      ]
    },
    "users": {
      "label": "Authors",
      "primaryKey": "id",
      "displayField": "name",
      "fields": [
        { "name": "id", "type": "number", "readOnly": true },
        { "name": "name", "type": "text", "required": true },
        { "name": "email", "type": "text", "required": true }
      ]
    }
  }
}
```

#### 2. CRUD Endpoints
Your API must expose standard RESTful endpoints for each resource defined in the schema.

- **List Records (with Pagination):**
  - **Endpoint:** `GET /admin/resources/posts?page=1&limit=10`
  - **Response Body:** Must return an object with a `data` array and a `total` count.
  ```json
  {
    "data": [
      { "id": 1, "title": "Hello World" },
      { "id": 2, "title": "Second Post" }
    ],
    "total": 100,
    "page": 1,
    "limit": 10
  }
  ```

- **Get One Record:**
  - **Endpoint:** `GET /admin/resources/posts/1`
  - **Response Body:** The single record object.

- **Create Record:**
  - **Endpoint:** `POST /admin/resources/posts`
  - **Request Body:** The new record data.

- **Update Record:**
  - **Endpoint:** `PATCH /admin/resources/posts/1`
  - **Request Body:** The fields to update.

- **Delete Record:**
  - **Endpoint:** `DELETE /admin/resources/posts/1`

### Your Micro-CMS Module Stack
Your implementation will be extremely simple:
```javascript
import { createApp } from '@micro-cms/core';
import adminUi from '@micro-cms/admin-ui';
import nodeAdapter from '@micro-cms/node-adapter';

const app = createApp();

// Configure the adapter to point to your API
app.use(nodeAdapter, { apiUrl: 'https://my-api.com' });

// Add the UI, which will auto-discover the adapter
app.use(adminUi);

app.start();
```

---

## Scenario 2: You Have an Empty Database

If you are starting a new project, you can use Micro-CMS modules to build your entire backend and frontend.

### Minimal Stack for a Headless REST API
To get a fully functional REST API for a blog without writing any backend code:

1.  **`@micro-cms/postgres` (Database Adapter):**
    - Connects to your empty PostgreSQL database.
    - It reads the table structure (e.g., `posts`, `users`) as soon as you create them.
    - **Provides:** `database-adapter` capability.

2.  **`@micro-cms/http-server` (Server Foundation):**
    - A simple module that wraps Express or Fastify.
    - Its only job is to open a port and listen for HTTP requests.
    - **Provides:** `http-server` capability.

3.  **`@micro-cms/rest-api` (Auto-Generated API):**
    - This is the core of the "headless" experience.
    - **Requires:** `database-adapter` and `http-server`.
    - It uses the `database-adapter` to `introspect` your schema.
    - For every table it finds, it **automatically creates all the CRUD and Schema endpoints** described in Scenario 1.

### Adding a CRUD UI
Once the headless API is running, you add one more module:

4.  **`@micro-cms/admin-ui` (Auto-Generated UI):**
    - **Requires:** A `database-adapter` or a `rest-api`.
    - It discovers the API generated by the `rest-api` module.
    - It calls the `/admin/schema` endpoint, gets the schema, and renders the entire UI with forms, tables, pagination, and relationships.

### Your Micro-CMS Module Stack
The final composition is a complete CMS:
```javascript
import { createApp } from '@micro-cms/core';
import postgresAdapter from '@micro-cms/postgres';
import httpServer from '@micro-cms/http-server';
import restApi from '@micro-cms/rest-api';
import adminUi from '@micro-cms/admin-ui';

const app = createApp();

// Compose the full stack
app.use(postgresAdapter, { connectionString: '...' });
app.use(httpServer, { port: 3000 });
app.use(restApi); // Discovers other modules
app.use(adminUi); // Discovers other modules

app.start();
```

## Summary Comparison

| Feature | Scenario 1 (Existing API) | Scenario 2 (Empty DB) |
| :--- | :--- | :--- |
| **Primary Module** | `@micro-cms/node-adapter` | A database adapter like `@micro-cms/postgres` |
| **Backend Work** | Ensure your API conforms to the contract. | Zero. Create tables in your DB. |
| **API Generation**| You maintain the API. | `@micro-cms/rest-api` generates it for you. |
| **Flexibility** | Keep your existing backend logic. | Build from scratch with composable parts. |
| **Minimal UI Stack** | `core` + `admin-ui` + `node-adapter` | `core` + `admin-ui` + `db-adapter` + `http-server` + `rest-api` |
